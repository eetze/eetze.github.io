<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[OpenGL ES 2.0基础教程（1）：渲染管线]]></title>
      <url>%2F2017%2F04%2F19%2FGLES20-01%2F</url>
      <content type="text"><![CDATA[大部分图形系统都可以比作工厂中的装配线(Assemble line)或者称为管线(Pipeline)。前一道的输出作为下道工序的输入。主CPU发出一个绘图指令，然后可能由硬件部件完成坐标变换，裁剪，添加颜色或是材质，最后在屏幕上显示出来。 可编程渲染管线在 OpenGL ES 1.x 版本中支持固定管线，而 OpenGL ES 2.0 版本不再支持固定管线，只支持可编程管线，比起 OpenGL ES 1.x 中的固定管线要复杂和灵活很多。可编程管线就是说管线中某些操作可以动态编程实现而不必固定写死在代码中。那可编程管线有什么好处呢？主要是方便动态修改渲染过程，而无需重写编译代码，当然也和很多脚本语言一样，调试起来不太方便。 下图为 OpenGL ES 2.0 渲染管线，阴影部分为可编程着色器。可动态编程实现这一功能通常都是通过脚本实现的，在 OpenGL ES 中也一样，编写着色器脚本的是由着色语言 (Shader Language) 提供的。 Vertex Arrays/Buffer ObjectsVertex Buffer Object 简称 VBO，顶点缓冲区对象，它是GPU里面的一块缓冲区，当我们需要传递数据的时候，可以先向GPU申请一块内存，然后往里面填充数据。最后，再通过调用glVertexAttribPointer把数据传递给Vertex Shader。 Vertex Arrays Object 简称 VAO，顶点数组对象，它的作用主要是记录当前有哪些VBO，每个VBO里面绑定的是什么数据，还有每一个 vertex attribute 绑定的是哪一个VBO。 VBO/VAO 是渲染管线的顶点数据来源，是CPU提供给GPU的，包括了顶点的位置、颜色、纹理坐标（用于纹理贴图）等顶点信息。 Vertex ShaderVertex Shader （顶点着色器）是处理 VBO/VAO 提供的顶点信息的程序，VBO/VAO提供的每个顶点都执行一遍顶点着色器程序。 通过可编程的方式实现对顶点的操作，如进行基于矩阵变换位置，进行光照计算来生成每个顶点的颜色，生成或者变换纹理坐标，另外因为顶点着色器是由应用程序指定的，所以你可以用来进行任意自定义的顶点变换。下图展示的顶点着色器的输入/输出情况： 顶点着色器的输入 Attributes：使用顶点数组封装每个顶点的数据，一般用于每个顶点都各不相同的变量，如顶点位置、颜色等。 Uniforms：顶点着色器使用的常量数据，不能被着色器修改，一般用于对同一组顶点组成的单个3D物体中所有顶点都相同的变量，如当前光源的位置。 Samplers：这个是可选的，一种特殊的 Uniforms ，表示顶点着色器使用的纹理。 顶点着色器的输出 Varying：顶点着色器的输出变量，作为片元着色器（Fragment Shader）的输入。在图元光栅化阶段，这些 Varying 值为每个生成的片元进行计算，并将结果作为片元着色器的输入数据。从分配给每个顶点的原始 Varying 值来为每个片元生成一个 Varying 值的机制叫做插值。 顶点着色器的特殊输出变量 gl_Postion：以裁剪坐标的方式输出“顶点位置”，且是一个highp变量。 gl_FrontFacing：以像素为单位输出“点的大小”，其值被限制在OpenGL ES 2.0可实现的范围内，且是一个mediump变量。 gl_PointSize：不直接由Vertex Shader写，是一个boolean变量。 Primitive AssemblyPrimitive Assembly（图元装配)，经过着色器处理之后的顶点在图片装配阶段被装配为基本图元，图元是一个能用OpenGL ES绘图命令绘制的几何体，绘图命令指定了一组顶点属性，描述了图元的几何形状和图元类型，OpenGL ES 支持三种基本图元：点，线和三角形，它们是可被 OpenGL ES 渲染的。 在图元装配阶段，这些顶点着色器处理过的顶点被组装到一个个独立的几何图元中，对于每个图元都必须确定它是否位于视椎体内（三维空间显示在屏幕上的可见区域），如果图元部分在视椎体中，需要进行裁剪，如果图元全部在视椎体外，则直接丢弃图元。裁剪之后，顶点位置转换成了屏幕坐标。背面剔除操作也会执行，它根据图元是正面还是背面，如果是背面则丢弃该图元。 裁剪（Clip）：保留完全在视锥体中的图元，丢弃完全不在视锥体中的图元，对一半在一半不在的图元进行裁剪。 剔除（Cull）：这个过程可编码来决定是剔除正面、背面还是全部剔除。 RasterizationRasterization（光栅化），在光栅化阶段，基本图元被转换为二维的片元(Fragment)，Fragment 表示可以被渲染到屏幕上的像素，它包含位置，颜色，纹理坐标等信息，这些值是由图元的顶点信息进行插值计算得到的。这些片元接着被送到片元着色器中处理。这是从顶点数据到可渲染在显示设备上的像素的质变过程。 用于从分配给每个图元顶点的顶点着色器输出生成每个片段值的机制称作插值（Interpolation）。这句不是人话的话解释了一个问题，就是从CPU提供的分散的顶点信息是如何变成屏幕上密集的像素的，图元装配后顶点可以理解成变为图形，光栅化时可以根据图形的形状，插值出那个图形区域的像素（纹理坐标v_texCoord、颜色等信息）。注意，此时的像素并不是屏幕上的像素，是不带有颜色的。接下来的片元着色器完成上色的工作。总之，光栅化阶段把图元转换成片元集合，之后会提交给片元着色器处理，这些片元集合表示可以被绘制到屏幕的像素。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenGL ES 2.0基础教程（0）：OpenGL ES 简介]]></title>
      <url>%2F2017%2F04%2F17%2FGLES20-00%2F</url>
      <content type="text"><![CDATA[OpenGL ES (OpenGL for Embedded Systems) 是针对手机、PDA和游戏主机等嵌入式设备而设计发展的 3D 绘图接口。OpenGL ES 是一个叫做 Khronos 组织创造的一系列接口中的一个。Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。 由来OpenGL (Open Graphics Library) 是一个跨编程语言、跨平台的专业底层图形接口，其具有功能强大、调用方便等特点，因此在 2D/3D 图形领域中被广泛使用。因为受制于嵌入式设备的硬件基础，因此 OpenGL 并不适用于嵌入式设备，所以 Khronos 团队对 OpenGL 进行了适当修改以适用于嵌入式设备，而 OpenGL ES 就是在 OpenGL 基础上进行裁剪定制而来的针对于嵌入式设备的图形接口，所以说 OpenGL ES 就是 OpenGL 的子集。 创建 OpenGL ES 的初衷是建立一个适合嵌入式设备驱动程序，为此 Khronos 团队删除了一些 OpenGL 中的冗余设计，对于同一种操作有多种适用方法的，只留下其主要的方法，多余的方法均被删除。例如绘制一个几何体，OpenGL 中可以使用立即模式、显示列表、顶点矩阵三种方法，但是在 OpenGL ES 中只能使用顶点矩阵，显示列表和立即模式被移除。 发展OpenGL ES 1.0 和 OpenGL ES 1.1 为固定渲染管线，分别从 OpenGL1.3 和 OpenGL1.5 发展而来。OpenGL ES 2.0 为可编程渲染管线，发展自 OpenGL 2.0。OpenGL ES 3.0 发展自 OpenGL 3.0。 因为 OpenGL ES 均是发展自 OpenGL，也就意味着 OpenGL 是 OpenGL ES 的基础，决定着未来 OenGL ES 的版本。 向后兼容OpenGL ES 2.0 不支持向后兼容 OpenGL ES 1.x，因为它不支持固定功能的管线。OpenGL ES 2.0 中使用可编程顶点着色器取代 OpenGL ES 1.x 固定功能的顶点着色器。 OpenGL ES 2.0 工作组决定不提供向后兼容能力主要基于如下考虑： 提供对固定功能管线的支持也就是暗示 API 将支持多种的方法执行一个特性，这违背了设计的初衷，可编程管线即使提供对固定管线的支持，也不会获得更多的注意。 对硬件供应商来说，那将有更多的工作要做，而可编程管线能提供更多的灵活性。 即支持固定管线，又支持可编程管线意味着设备需要更多的内存，而如果分离固定管线和可编程管线，厂商就不需要更多的驱动支持。 而且，不同于 OpenGL ES 1.x，OpenGL ES 2.0 中没有配置文件或扩展命令。 Android系统支持OpenGL ES 1.x 支持 初代 AndroidOpenGL ES 2.0 支持 Android 2.2 以后的平台。OpenGL ES 3.0 支持 Android 4.3 以后的平台。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Windows下使用Bash]]></title>
      <url>%2F2017%2F04%2F12%2FBashOnWindows%2F</url>
      <content type="text"><![CDATA[在 Windows10 14316 版本中更新了 Bash on Ubuntu on Windows 功能，允许在 Windows 上运行 Ubuntu Bash，虽然与原生的Bash相比还有些缺陷，不过大部分功能还是能够正常使用的。 安装 BashOnWindows检查Windows10版本想要使用 BashOnWindows 需要Windows10版本为 14316 以上版本，可以通过下面三种方法查看当前Windows10版本。 打开cmd命令行，最上面会显示当前版本。 使用cmd命令，输入 ver 可以查看当前版本。 在运行中输入 msinfo32，可在系统信息中查看当前版本。 打开开发人员模式在 windwos 的 设置 中打开 更新和安全 ，然后在左侧列表中选择 针对开发人员 ,右侧选择 开发人员模式。如果提示失败则检查 Windows Update 服务是否已经打开。 下载BashOnWindows在 控制面板 中打开 程序 ，然后在 程序和功能 中打开 启用或关闭Windows功能 ，接着在弹出的窗口中勾选 适用于Linux的Windows子系统(Beta) ，系统会下载更新并提示重启机器。 系统重启完成后，进入cmd命令行，输入 bash 后会提示你是否继续，选择 y ，系统会安装 Ubuntu Bash ，等待安装完成后会提示创建账号，之后就进入熟悉的Bash了。可能会遇到安装失败，因为下载节点在国外，这个时候打开代理便可以进行下载。 之后就可以在 cmd 或者 PowerShell 中输入 bash 进入 Bash 了。 更换软件更新源把下面的阿里源内容粘贴到 /etc/apt/sources.list ，之后运行 sudo apt-get update 完成更新后就可以通过 apt-get 进行常用软件的安装了。 12345678910deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse Cmder启动Bash如果经常使用Bash的话，使用cmd 的配色会感觉过于朴实，接下来通过 Cmder 来对 Bash 进行美化。 Cmder下载首先登录 Cmder官网 进行下载，下载时会有 mini 与 full 两个版版，其差别在于有没有内建git-for-windows工具，选择full版本进行下载。 下载完成后会得到一个压缩包，解压完成即可使用。 右键添加在当前位置打开想要快捷方便的打开 Cmder ，一般会将其添加到鼠标右键菜单中。在 Cmder.exe 所在文件夹打开带管理员权限的 cmd 命令行，输入如下指令。 1Cmder.exe /REGISTER ALL 之后就可以在任意位置通过鼠标右键打开Cmder了。 使用Cmder打开Bash安装 Cmder 的目的就是希望通过它来代替 cmd 打开 Bash ，接下来就是设置如何打开 Bash 。 在 Cmder 中选择 Setting ，然后在 Startup -&gt; Tasks -&gt; {cmd::Cmder} 中输入如下启动方式，这样就可以通过鼠标右键菜单打开 Bash 了，并且是在当前文件夹打开，同时也避免了在 Vim 中方向键失灵的问题。 1cmd /k &quot;%ConEmuDir%\..\init.bat&quot; -new_console:p:n%USERPROFILE% &amp;bash 但是设置完如上启动方式之后，每次关闭时都会弹出提示框提示 Confirm closing console? ，只需要在 Setting -&gt; Main -&gt; Confirm -&gt; Close confirmations 中取消 When running process was detected 前面选中状态，就可以关闭提示框的弹出。 Zsh代替BashBash 虽然很不错，但是 Zsh 在自动补全方面的强大还是让我投入 Zsh 的怀抱，另外 Zsh 的主题用起来也很方便。 安装ZshZsh 安装起来简单，但是配置起来却十分麻烦，不过还好已经有了 oh-my-zsh ， 直接通过在 Bash 下输入下面指令安装 Zsh 及配置。 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 或者 1sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 安装完成后就可以在 Bash 中输入 zsh 进入 Zsh。 Zsh主题oh-my-zsh 中有140多种主题供选择，可以去 oh-my-zsh主题 页面选择自己喜欢的主题。 选择好自己喜欢的主题后打开 ~/.zshrc ，修改 ZSH_THEME 为自己选择的主题名字即可。例如下面就是将主题设置为 ys 主题。 Bash默认启动Zsh每次运行 Cmder 现在已经默认启动 Bash 了，但是进入 Zsh 还要手动输入，接下来就是设置启动 Bash 时自动进入 Zsh。 在 ~/.bashrc 文件末尾添加如下代码，即可实现 Zsh 的自动进入了。 1bash -c zsh]]></content>
    </entry>

    
  
  
</search>
