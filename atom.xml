<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eetze的博客</title>
  <subtitle>自知者不怨人  知命者不怨天</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://eetze.github.io/"/>
  <updated>2017-04-21T06:54:27.878Z</updated>
  <id>https://eetze.github.io/</id>
  
  <author>
    <name>Eetze</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenGL ES 2.0基础教程（1）：渲染管线</title>
    <link href="https://eetze.github.io/2017/04/19/GLES20-01/"/>
    <id>https://eetze.github.io/2017/04/19/GLES20-01/</id>
    <published>2017-04-19T06:12:16.000Z</published>
    <updated>2017-04-21T06:54:27.878Z</updated>
    
    <content type="html"><![CDATA[<div class="note primary"><p>大部分图形系统都可以比作工厂中的装配线(Assemble line)或者称为管线(Pipeline)。前一道的输出作为下道工序的输入。主CPU发出一个绘图指令，然后可能由硬件部件完成坐标变换，裁剪，添加颜色或是材质，最后在屏幕上显示出来。 </p>
</div>
<a id="more"></a>
<h3 id="可编程渲染管线"><a href="#可编程渲染管线" class="headerlink" title="可编程渲染管线"></a>可编程渲染管线</h3><p>在 OpenGL ES 1.x 版本中支持固定管线，而 <strong>OpenGL ES 2.0 版本不再支持固定管线，只支持可编程管线</strong>，比起 OpenGL ES 1.x 中的固定管线要复杂和灵活很多。可编程管线就是说管线中某些操作可以动态编程实现而不必固定写死在代码中。那可编程管线有什么好处呢？主要是方便动态修改渲染过程，而无需重写编译代码，当然也和很多脚本语言一样，调试起来不太方便。</p>
<p>下图为 OpenGL ES 2.0 渲染管线，阴影部分为可编程着色器。可动态编程实现这一功能通常都是通过脚本实现的，在 OpenGL ES 中也一样，编写着色器脚本的是由着色语言 (Shader Language) 提供的。</p>
<p><img src="/2017/04/19/GLES20-01/Pipeline.png" alt="logo"></p>
<hr>
<h3 id="顶点数据"><a href="#顶点数据" class="headerlink" title="顶点数据"></a>顶点数据</h3><p><strong>顶点缓冲区对象</strong>（Vertex Buffer Object） 简称 <strong>VBO</strong>，它是GPU里面的一块缓冲区，当我们需要传递数据的时候，可以先向GPU申请一块内存，然后往里面填充数据。最后，再通过调用glVertexAttribPointer把数据传递给Vertex Shader。  </p>
<p><strong>顶点数组对象</strong>（Vertex Arrays Object） 简称 <strong>VAO</strong>，它的作用主要是记录当前有哪些VBO，每个VBO里面绑定的是什么数据，还有每一个 vertex attribute 绑定的是哪一个VBO。</p>
<p>VBO/VAO 是渲染管线的顶点数据来源，是CPU提供给GPU的，包括了顶点的位置、颜色、纹理坐标（用于纹理贴图）等顶点信息。 </p>
<hr>
<h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p><strong>顶点着色器</strong> （Vertex Shader）是处理 VBO/VAO 提供的顶点信息的程序，VBO/VAO提供的每个顶点都执行一遍顶点着色器程序。 <strong>通过可编程的方式实现对顶点的操作，如进行基于矩阵变换位置，进行光照计算来生成每个顶点的颜色，生成或者变换纹理坐标</strong>，另外因为顶点着色器是由应用程序指定的，所以你可以用来进行任意自定义的顶点变换。下图展示为顶点着色器的输入/输出情况：</p>
<p><img src="/2017/04/19/GLES20-01/VertexShader.png" alt="log"></p>
<h4 id="顶点着色器的输入"><a href="#顶点着色器的输入" class="headerlink" title="顶点着色器的输入"></a>顶点着色器的输入</h4><ul>
<li>Attributes：使用顶点数组封装每个顶点的数据，一般用于每个顶点都各不相同的变量，如顶点位置、颜色等。</li>
<li>Uniforms：顶点着色器使用的常量数据，不能被着色器修改，一般用于对同一组顶点组成的单个3D物体中所有顶点都相同的变量，如当前光源的位置。</li>
<li>Samplers：这个是可选的，一种特殊的 Uniforms ，表示顶点着色器使用的纹理。</li>
</ul>
<h4 id="顶点着色器的输出"><a href="#顶点着色器的输出" class="headerlink" title="顶点着色器的输出"></a>顶点着色器的输出</h4><ul>
<li>Varying：顶点着色器的输出变量，作为片元着色器（Fragment Shader）的输入。在图元光栅化阶段，这些 Varying 值为每个生成的片元进行计算，并将结果作为片元着色器的输入数据。从分配给每个顶点的原始 Varying 值来为每个片元生成一个 Varying 值的机制叫做插值。</li>
</ul>
<h4 id="顶点着色器的特殊输出变量"><a href="#顶点着色器的特殊输出变量" class="headerlink" title="顶点着色器的特殊输出变量"></a>顶点着色器的特殊输出变量</h4><ul>
<li>gl_Postion：以裁剪坐标的方式输出“顶点位置”，且是一个highp变量。</li>
<li>gl_FrontFacing：以像素为单位输出“点的大小”，其值被限制在OpenGL ES 2.0可实现的范围内，且是一个mediump变量。</li>
<li>gl_PointSize：不直接由Vertex Shader写，是一个boolean变量。</li>
</ul>
<hr>
<h3 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h3><p><img src="/2017/04/19/GLES20-01/PrimitiveAssembly.png" alt="logo"></p>
<p><strong>图元装配</strong>（Primitive Assembly)，经过着色器处理之后的<strong>顶点在图元装配阶段被装配为基本图元</strong>，图元是一个能用OpenGL ES绘图命令绘制的几何体，绘图命令指定了一组顶点属性，描述了图元的几何形状和图元类型，OpenGL ES 支持三种基本图元：点，线和三角形，它们是可被 OpenGL ES 渲染的。</p>
<p>在图元装配阶段，这些顶点着色器处理过的顶点被组装到一个个独立的几何图元中，对于每个图元都必须确定它是否位于视椎体内（三维空间显示在屏幕上的可见区域），如果图元部分在视椎体中，需要进行裁剪，如果图元全部在视椎体外，则直接丢弃图元。裁剪之后，顶点位置转换成了屏幕坐标。背面剔除操作也会执行，它根据图元是正面还是背面，如果是背面则丢弃该图元。</p>
<ul>
<li>裁剪（Clip）：保留完全在视锥体中的图元，丢弃完全不在视锥体中的图元，对一半在一半不在的图元进行裁剪。</li>
<li>剔除（Cull）：这个过程可编码来决定是剔除正面、背面还是全部剔除。</li>
</ul>
<hr>
<h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p><img src="/2017/04/19/GLES20-01/Rasterization.png" alt="log"></p>
<p><strong>光栅化</strong>（Rasterization），在光栅化阶段基本图元（点、线、三角形）被转换为二维的片元(Fragment)，Fragment 表示可以被渲染到屏幕上的像素，它包含位置，颜色，纹理坐标等信息，这些值是由图元的顶点信息进行插值计算得到的。这些片元接着被送到片元着色器中处理。这是<strong>从顶点数据到可渲染在显示设备上的像素的质变过程</strong>。</p>
<p>用于从分配给每个图元顶点的顶点着色器输出生成每个片段值的机制称作插值（Interpolation）。这句不是人话的话解释了一个问题，就是从CPU提供的分散的顶点信息是如何变成屏幕上密集的像素的，图元装配后顶点可以理解成变为图形，光栅化时可以根据图形的形状，插值出那个图形区域的像素（纹理坐标v_texCoord、颜色等信息）。注意，此时的像素并不是屏幕上的像素，是不带有颜色的。接下来的片元着色器完成上色的工作。总之，光栅化阶段把图元转换成片元集合，之后会提交给片元着色器处理，这些片元集合表示可以被绘制到屏幕的像素。</p>
<hr>
<h3 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h3><p><strong>片元着色器</strong>（Fragment Shader），片元着色器通过可编程的方式实现对片元的操作，光栅化阶段生成每个片元都需要执行这个着色器程序，生成一个或多个（多重渲染）颜色值作为输出。下图展示为片元着色器的输入/输出情况：</p>
<p><img src="/2017/04/19/GLES20-01/FragmentShader.png" alt="log"></p>
<h4 id="片元着色器的输入"><a href="#片元着色器的输入" class="headerlink" title="片元着色器的输入"></a>片元着色器的输入</h4><ul>
<li>Varying：顶点着色器输出的varying变量经过光栅化插值计算后产生的作用于每个片元的值。</li>
<li>Uniforms：片元着色器使用的常量数据。</li>
<li>Samplers：一种特殊的uniforms，表示片元着色器使用的纹理。</li>
</ul>
<h4 id="片元着色器的输出"><a href="#片元着色器的输出" class="headerlink" title="片元着色器的输出"></a>片元着色器的输出</h4><p>片元着色器可以丢弃片元或者为片元生成一个颜色值，保存到内置变量gl_FragColor。</p>
<hr>
<h3 id="逐片元操作"><a href="#逐片元操作" class="headerlink" title="逐片元操作"></a>逐片元操作</h3><p><strong>逐片元操作</strong>（Per-Fragment Operation），一个光栅化阶段产生的具有屏幕坐标(Xw, Yw)的片元，只能修改 <strong>Framebuffer</strong> (<strong>帧缓存</strong>)中位置在(Xw, Yw)的像素，在这一阶段对每一个片元进行一系列测试与处理，从而决定最终用于渲染的像素。这一系列处理过程如下：</p>
<p><img src="/2017/04/19/GLES20-01/PerFragmentOperation.png" alt="log"></p>
<ul>
<li>像素所有权测试（Pixel Ownership Test）：决定 Framebuffer 中某一个(Xw, Yw)位置的像素是否属于当前Opengl ES的Context。比如：如果一个OpenGL ES帧缓冲窗口被其他窗口遮住了，窗口系统将决定被遮住的像素不属于当前OpenGL ES的Context，因此也就不会被显示。</li>
<li>裁剪测试（Scissor Test）：裁剪测试决定位置为(Xw, Yw)的片元是否位于裁剪矩形内，如果不在，则被丢弃。</li>
<li>模板测试（Stencil Test）：根据传入片元的模板，决定是否丢弃片元。</li>
<li>深度测试（Depth Test）：根据传入片元的深度值，决定是否丢弃片元。</li>
<li>混合（Blending）：将新产生的片元颜色值和Framebuffer中某个(Xw, Yw)位置存储的颜色值进行混合。</li>
<li>抖动（Dithering）：抖动可以用来最大限度的减少使用有限精度存储颜色值到Framebuffer的工件。</li>
</ul>
<p>逐片元操作之后，片元要么被丢弃，要么一个片元的颜色、深度或者模板值被写入到Framebuffer的(Xw, Yw)位置，不过是否真的会写入还得依赖于Write Masks启用与否。Write Masks能更好的控制颜色、深度和模板值写入到合适的缓冲区。例如：颜色缓冲区中的Write Masks可以被设置成没有红色值写入到颜色缓冲区。</p>
<hr>
<h3 id="帧缓存"><a href="#帧缓存" class="headerlink" title="帧缓存"></a>帧缓存</h3><p><strong>帧缓存</strong>（Framebuffer），这是OpenGL ES 2.0渲染管线的最后一个阶段，Framebuffer 中存储这可以用于渲染到屏幕或纹理中的像素值，Opengl ES 2.0提供从Framebuffer中获取像素的接口，但不能读取其它值（如深度值，模版值等）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;大部分图形系统都可以比作工厂中的装配线(Assemble line)或者称为管线(Pipeline)。前一道的输出作为下道工序的输入。主CPU发出一个绘图指令，然后可能由硬件部件完成坐标变换，裁剪，添加颜色或是材质，最后在屏幕上显示出来。 &lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="Android OpenGL ES 2.0基础教程" scheme="https://eetze.github.io/categories/Android-OpenGL-ES-2-0%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="OpenGL ES 2.0" scheme="https://eetze.github.io/tags/OpenGL-ES-2-0/"/>
    
      <category term="Android" scheme="https://eetze.github.io/tags/Android/"/>
    
      <category term="渲染管线" scheme="https://eetze.github.io/tags/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    
      <category term="可编程渲染管线" scheme="https://eetze.github.io/tags/%E5%8F%AF%E7%BC%96%E7%A8%8B%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES 2.0基础教程（0）：OpenGL ES 简介</title>
    <link href="https://eetze.github.io/2017/04/17/GLES20-00/"/>
    <id>https://eetze.github.io/2017/04/17/GLES20-00/</id>
    <published>2017-04-17T07:41:17.000Z</published>
    <updated>2017-04-20T14:37:41.411Z</updated>
    
    <content type="html"><![CDATA[<div class="note primary"><p>OpenGL ES (OpenGL for Embedded Systems) 是针对手机、PDA和游戏主机等嵌入式设备而设计发展的 3D 绘图接口。OpenGL ES 是一个叫做 <a href="https://www.khronos.org/" target="_blank" rel="external">Khronos</a> 组织创造的一系列接口中的一个。Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。 </p>
</div>
<p><img src="/2017/04/17/GLES20-00/opengles.png" alt="logo"></p>
<a id="more"></a>
<hr>
<h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>OpenGL (Open Graphics Library) 是一个跨编程语言、跨平台的专业底层图形接口，其具有功能强大、调用方便等特点，因此在 2D/3D 图形领域中被广泛使用。因为受制于嵌入式设备的硬件基础，因此 OpenGL 并不适用于嵌入式设备，所以 Khronos 团队对 OpenGL 进行了适当修改以适用于嵌入式设备，而 OpenGL ES 就是在 OpenGL 基础上进行裁剪定制而来的针对于嵌入式设备的图形接口，所以说 OpenGL ES 就是 OpenGL 的子集。</p>
<p>创建 OpenGL ES 的初衷是建立一个适合嵌入式设备驱动程序，为此 Khronos 团队删除了一些 OpenGL 中的冗余设计，对于同一种操作有多种适用方法的，只留下其主要的方法，多余的方法均被删除。例如绘制一个几何体，OpenGL 中可以使用立即模式、显示列表、顶点矩阵三种方法，但是在 OpenGL ES 中只能使用顶点矩阵，显示列表和立即模式被移除。</p>
<hr>
<h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>OpenGL ES 1.0 和 OpenGL ES 1.1 为<strong>固定渲染管线</strong>，分别从 OpenGL1.3 和 OpenGL1.5 发展而来。OpenGL ES 2.0 为<strong>可编程渲染管线</strong>，发展自 OpenGL 2.0。OpenGL ES 3.0 发展自 OpenGL 3.0。</p>
<p><img src="/2017/04/17/GLES20-00/Version.png" alt="logo"></p>
<p>因为 OpenGL ES 均是发展自 OpenGL，也就意味着 OpenGL 是 OpenGL ES 的基础，决定着未来 OenGL ES 的版本。</p>
<hr>
<h3 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h3><p>OpenGL ES 2.0 不支持向后兼容 OpenGL ES 1.x，因为它不支持固定功能的管线。OpenGL ES 2.0 中使用可编程顶点着色器取代 OpenGL ES 1.x 固定功能的顶点着色器。</p>
<p>OpenGL ES 2.0 工作组决定不提供向后兼容能力主要基于如下考虑：</p>
<ol>
<li><p>提供对固定功能管线的支持也就是暗示 API 将支持多种的方法执行一个特性，这违背了设计的初衷，可编程管线即使提供对固定管线的支持，也不会获得更多的注意。</p>
</li>
<li><p>对硬件供应商来说，那将有更多的工作要做，而可编程管线能提供更多的灵活性。</p>
</li>
<li><p>即支持固定管线，又支持可编程管线意味着设备需要更多的内存，而如果分离固定管线和可编程管线，厂商就不需要更多的驱动支持。</p>
</li>
</ol>
<p>而且，不同于 OpenGL ES 1.x，OpenGL ES 2.0 中没有配置文件或扩展命令。</p>
<hr>
<h3 id="Android系统支持"><a href="#Android系统支持" class="headerlink" title="Android系统支持"></a>Android系统支持</h3><p>OpenGL ES 1.x 支持 初代 Android<br>OpenGL ES 2.0 支持 Android 2.2 以后的平台。<br>OpenGL ES 3.0 支持 Android 4.3 以后的平台。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;OpenGL ES (OpenGL for Embedded Systems) 是针对手机、PDA和游戏主机等嵌入式设备而设计发展的 3D 绘图接口。OpenGL ES 是一个叫做 &lt;a href=&quot;https://www.khronos.org/&quot;&gt;Khronos&lt;/a&gt; 组织创造的一系列接口中的一个。Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。 &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/2017/04/17/GLES20-00/opengles.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android OpenGL ES 2.0基础教程" scheme="https://eetze.github.io/categories/Android-OpenGL-ES-2-0%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="OpenGL ES 2.0" scheme="https://eetze.github.io/tags/OpenGL-ES-2-0/"/>
    
      <category term="Android" scheme="https://eetze.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Windows下使用Bash</title>
    <link href="https://eetze.github.io/2017/04/12/BashOnWindows/"/>
    <id>https://eetze.github.io/2017/04/12/BashOnWindows/</id>
    <published>2017-04-12T05:39:49.000Z</published>
    <updated>2017-04-17T08:09:30.222Z</updated>
    
    <content type="html"><![CDATA[<div class="note primary"><p>在 Windows10 <code>14316</code> 版本中更新了 <code>Bash on Ubuntu on Windows</code> 功能，允许在 Windows 上运行 Ubuntu Bash，虽然与原生的Bash相比还有些缺陷，不过大部分功能还是能够正常使用的。 </p>
</div>
<p><img src="/2017/04/12/BashOnWindows/20170412135721.png" alt="logo"></p>
<a id="more"></a>
<hr>
<h3 id="安装-BashOnWindows"><a href="#安装-BashOnWindows" class="headerlink" title="安装 BashOnWindows"></a>安装 BashOnWindows</h3><h4 id="检查Windows10版本"><a href="#检查Windows10版本" class="headerlink" title="检查Windows10版本"></a>检查Windows10版本</h4><p>想要使用 <code>BashOnWindows</code> 需要Windows10版本为 <code>14316</code> 以上版本，可以通过下面三种方法查看当前Windows10版本。</p>
<ul>
<li>打开cmd命令行，最上面会显示当前版本。</li>
</ul>
<p><img src="/2017/04/12/BashOnWindows/20170412134410.png" alt="logo"></p>
<ul>
<li>使用cmd命令，输入 ver 可以查看当前版本。</li>
</ul>
<p><img src="/2017/04/12/BashOnWindows/20170412134501.png" alt="logo"></p>
<ul>
<li>在运行中输入 msinfo32，可在系统信息中查看当前版本。</li>
</ul>
<p><img src="/2017/04/12/BashOnWindows/20170412134605.png" alt="logo"></p>
<h4 id="打开开发人员模式"><a href="#打开开发人员模式" class="headerlink" title="打开开发人员模式"></a>打开开发人员模式</h4><p>在 windwos 的 <code>设置</code> 中打开 <code>更新和安全</code> ，然后在左侧列表中选择 <code>针对开发人员</code> ,右侧选择 <code>开发人员模式</code>。如果提示失败则检查 <code>Windows Update</code> 服务是否已经打开。</p>
<p><img src="/2017/04/12/BashOnWindows/20170412140708.png" alt="logo"></p>
<h4 id="下载BashOnWindows"><a href="#下载BashOnWindows" class="headerlink" title="下载BashOnWindows"></a>下载BashOnWindows</h4><p>在 <code>控制面板</code> 中打开 <code>程序</code> ，然后在 <code>程序和功能</code> 中打开 <code>启用或关闭Windows功能</code> ，接着在弹出的窗口中勾选 <code>适用于Linux的Windows子系统(Beta)</code> ，系统会下载更新并提示重启机器。</p>
<p><img src="/2017/04/12/BashOnWindows/20170412141538.png" alt="logo"></p>
<p>系统重启完成后，进入cmd命令行，输入 bash 后会提示你是否继续，选择 y ，系统会安装 Ubuntu Bash ，等待安装完成后会提示创建账号，之后就进入熟悉的Bash了。可能会遇到安装失败，因为下载节点在国外，这个时候打开代理便可以进行下载。</p>
<p><img src="/2017/04/12/BashOnWindows/20170412143808.png" alt="logo"></p>
<p>之后就可以在 cmd 或者 PowerShell 中输入 bash 进入 Bash 了。</p>
<p><img src="/2017/04/12/BashOnWindows/20170412145518.png" alt="logo"></p>
<h4 id="更换软件更新源"><a href="#更换软件更新源" class="headerlink" title="更换软件更新源"></a>更换软件更新源</h4><p>把下面的阿里源内容粘贴到 <code>/etc/apt/sources.list</code> ，之后运行 <code>sudo apt-get update</code> 完成更新后就可以通过 <code>apt-get</code> 进行常用软件的安装了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</div><div class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse</div><div class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</div></pre></td></tr></table></figure>
<hr>
<h3 id="Cmder启动Bash"><a href="#Cmder启动Bash" class="headerlink" title="Cmder启动Bash"></a>Cmder启动Bash</h3><p>如果经常使用Bash的话，使用cmd 的配色会感觉过于朴实，接下来通过 Cmder 来对 Bash 进行美化。</p>
<h4 id="Cmder下载"><a href="#Cmder下载" class="headerlink" title="Cmder下载"></a>Cmder下载</h4><p>首先登录 <a href="http://cmder.net/" target="_blank" rel="external">Cmder官网</a> 进行下载，下载时会有 mini 与 full 两个版版，其差别在于有没有内建git-for-windows工具，选择full版本进行下载。</p>
<p><img src="/2017/04/12/BashOnWindows/20170412151059.png" alt="logo"></p>
<p>下载完成后会得到一个压缩包，解压完成即可使用。</p>
<h4 id="右键添加在当前位置打开"><a href="#右键添加在当前位置打开" class="headerlink" title="右键添加在当前位置打开"></a>右键添加在当前位置打开</h4><p>想要快捷方便的打开 Cmder ，一般会将其添加到鼠标右键菜单中。在 Cmder.exe 所在文件夹打开带管理员权限的 cmd 命令行，输入如下指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cmder.exe /REGISTER ALL</div></pre></td></tr></table></figure>
<p>之后就可以在任意位置通过鼠标右键打开Cmder了。</p>
<p><img src="/2017/04/12/BashOnWindows/20170412160423.png" alt="logo"></p>
<h4 id="使用Cmder打开Bash"><a href="#使用Cmder打开Bash" class="headerlink" title="使用Cmder打开Bash"></a>使用Cmder打开Bash</h4><p>安装 Cmder 的目的就是希望通过它来代替 cmd 打开 Bash ，接下来就是设置如何打开 Bash 。</p>
<p>在 Cmder 中选择 <code>Setting</code> ，然后在 <code>Startup</code> -&gt; <code>Tasks</code> -&gt; <code>{cmd::Cmder}</code> 中输入如下启动方式，这样就可以通过鼠标右键菜单打开 Bash 了，并且是在当前文件夹打开，同时也避免了在 Vim 中方向键失灵的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cmd /k &quot;%ConEmuDir%\..\init.bat&quot;  -new_console:p:n%USERPROFILE% &amp;bash</div></pre></td></tr></table></figure>
<p>但是设置完如上启动方式之后，每次关闭时都会弹出提示框提示 <code>Confirm closing console?</code> ，只需要在 <code>Setting</code> -&gt; <code>Main</code> -&gt; <code>Confirm</code> -&gt; <code>Close confirmations</code> 中取消 <code>When running process was detected</code> 前面选中状态，就可以关闭提示框的弹出。</p>
<p><img src="/2017/04/12/BashOnWindows/20170412161554.png" alt="logo"></p>
<hr>
<h3 id="Zsh代替Bash"><a href="#Zsh代替Bash" class="headerlink" title="Zsh代替Bash"></a>Zsh代替Bash</h3><p>Bash 虽然很不错，但是 Zsh 在自动补全方面的强大还是让我投入 Zsh 的怀抱，另外 Zsh 的主题用起来也很方便。</p>
<h4 id="安装Zsh"><a href="#安装Zsh" class="headerlink" title="安装Zsh"></a>安装Zsh</h4><p>Zsh 安装起来简单，但是配置起来却十分麻烦，不过还好已经有了 <a href="https://github.com/robbyrussell/oh-my-zsh/" target="_blank" rel="external">oh-my-zsh</a> ， 直接通过在 Bash 下输入下面指令安装 Zsh 及配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</div></pre></td></tr></table></figure>
<p>安装完成后就可以在 Bash 中输入 zsh 进入 Zsh。</p>
<h4 id="Zsh主题"><a href="#Zsh主题" class="headerlink" title="Zsh主题"></a>Zsh主题</h4><p>oh-my-zsh 中有140多种主题供选择，可以去 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="external">oh-my-zsh主题</a> 页面选择自己喜欢的主题。</p>
<p>选择好自己喜欢的主题后打开 <code>~/.zshrc</code> ，修改 <code>ZSH_THEME</code> 为自己选择的主题名字即可。例如下面就是将主题设置为 <code>ys</code> 主题。</p>
<p><img src="/2017/04/12/BashOnWindows/20170412164748.png" alt="logo"></p>
<h4 id="Bash默认启动Zsh"><a href="#Bash默认启动Zsh" class="headerlink" title="Bash默认启动Zsh"></a>Bash默认启动Zsh</h4><p>每次运行 Cmder 现在已经默认启动 Bash 了，但是进入 Zsh 还要手动输入，接下来就是设置启动 Bash 时自动进入 Zsh。</p>
<p>在 <code>~/.bashrc</code> 文件末尾添加如下代码，即可实现 Zsh 的自动进入了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash -c zsh</div></pre></td></tr></table></figure>
<p><img src="/2017/04/12/BashOnWindows/20170412173246.png" alt="logo"></p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;在 Windows10 &lt;code&gt;14316&lt;/code&gt; 版本中更新了 &lt;code&gt;Bash on Ubuntu on Windows&lt;/code&gt; 功能，允许在 Windows 上运行 Ubuntu Bash，虽然与原生的Bash相比还有些缺陷，不过大部分功能还是能够正常使用的。 &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/2017/04/12/BashOnWindows/20170412135721.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="BashOnWindows" scheme="https://eetze.github.io/tags/BashOnWindows/"/>
    
      <category term="Bash" scheme="https://eetze.github.io/tags/Bash/"/>
    
      <category term="Cmder" scheme="https://eetze.github.io/tags/Cmder/"/>
    
      <category term="Zsh" scheme="https://eetze.github.io/tags/Zsh/"/>
    
  </entry>
  
</feed>
